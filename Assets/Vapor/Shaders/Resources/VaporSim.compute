#pragma kernel FogDensity SCATTER_SHADOW SHADOW_CASCADE
#pragma kernel ZoneWrite

#pragma kernel LightDirectional SCATTER_SHADOW SHADOW_CASCADE
#pragma kernel LightDirectionalShadow SCATTER_SHADOW
#pragma kernel LightDirectionalShadowCascade SCATTER_SHADOW SHADOW_CASCADE

#pragma kernel LightPoint
#pragma kernel LightSpot
#pragma kernel LightSpotShadow SCATTER_SHADOW

#pragma kernel Scatter
#pragma kernel Integrate

#include "VaporFramework.cginc"

float _ExponentialWeight;

RWTexture3D<half4> _ScatterTexture;
Texture3D<half4> _ScatterTextureOld;

RWTexture3D<half4> _IntegratedTexture;
RWTexture3D<half4> _DensityTextureWrite;

RWTexture3D<half> _LightAccumR;
RWTexture3D<half> _LightAccumG;
RWTexture3D<half> _LightAccumB;

Texture3D<half> _LightReadR;
Texture3D<half> _LightReadG;
Texture3D<half> _LightReadB;

Texture3D<half4> _DensityTexture;
Texture3D<half4> _DensityTextureOld;

Texture2D _GradientTexture;
SamplerState sampler_GradientTexture;

float4 _GradientSettings;


/*
#define DECLARE_NOISE_LAYER(n)	\
float4 _NoiseScale##n;			\
float4 _NoiseScroll##n;			\
Texture3D _NoiseTex##n;

DECLARE_NOISE_LAYER(0)
DECLARE_NOISE_LAYER(1)
DECLARE_NOISE_LAYER(2)
*/

//Main Light data
float4 _LightColor;
float4 _CameraPos;
float4 _LightPosRange;
Texture2D<float> _ShadowMapTexture;

//Spot light data
Texture2D _SpotCookie;
SamplerState sampler_SpotCookie;
Texture2D _SpotShadow;

//Shadow stuff
SamplerState MyLinearRepeatSampler;
SamplerState MyLinearClampSampler;

StructuredBuffer<float4x4> _MatrixBuf;
StructuredBuffer<float4> _LightSplits;

float _ShadowSoft;
float _ShadowBias;

//Cascade clamp. 
float4 _ShadowRange;

//To world & reprojection
float4x4 _VAPOR_REPROJECT;

uint _Frame;

//Global fog properties
float4 _AlbedoExt;
float4 _EmissivePhase;

float _TemporalStrength;
uint3 _LightWriteLower;

uint wang_hash(uint3 id)
{
	uint seed = (id.x + id.y * X_RESOLUTION + id.z * X_RESOLUTION * Y_RESOLUTION) ^ _Frame;
	seed = (seed ^ 61) ^ (seed >> 16);
	seed *= 9;
	seed = seed ^ (seed >> 4);
	seed *= 0x27d4eb2d;
	seed = seed ^ (seed >> 15);
	return seed;
}
uint xorshift(uint seed)
{
	// Xorshift algorithm from George Marsaglia's paper
	seed ^= (seed << 13);
	seed ^= (seed >> 17);
	seed ^= (seed << 5);
	return seed;
}

float GetHalton(uint3 id, uint base) {
	uint wang = wang_hash(id);
	return (wang / UINT_MAX - 0.5f) * _TemporalStrength + 0.5f;
}

float GetShadow(float3 wpos, float z){
	float4 multPos = float4(wpos, 1.0f);
	float4 coords;

	float4 splits = _LightSplits[0];

#if SHADOW_CASCADE
	[branch]
	if (z < splits.x){
		coords = mul(_MatrixBuf[0], multPos);
		coords.xy /= coords.w;
		
		coords.x = min(coords.x, _ShadowRange.x);
		coords.y = min(coords.y, _ShadowRange.y);
	}else if (z < splits.y){
		coords = mul(_MatrixBuf[1], multPos);
		coords.xy /= coords.w;

		coords.x = max(coords.x, _ShadowRange.x);
		coords.y = min(coords.y, _ShadowRange.y);
	}else if (z < splits.z){
		coords = mul(_MatrixBuf[2], multPos);
		coords.xy /= coords.w;

		coords.x = min(coords.x, _ShadowRange.x);
		coords.y = max(coords.y, _ShadowRange.y);
	}else if (z < splits.w){
		coords = mul(_MatrixBuf[3], multPos);
		coords.xy /= coords.w;

		coords.x = max(coords.x, _ShadowRange.x);
		coords.y = max(coords.y, _ShadowRange.y);
	}
#else
	coords = mul(_MatrixBuf[0], multPos);
	coords.xy /= coords.w;
#endif

	//TODO: Volumetric shadow maps would be so damn sexy
	float depth = _ShadowMapTexture.SampleLevel(MyLinearClampSampler, coords.xy, 0.0f).r;
	return saturate(depth * exp(-_ShadowSoft * saturate(coords.z + _ShadowBias)));
	//return depth >= saturate(coords.z +_ShadowBias) ? 1.0f : 0.0f;
}
float GetScatterHenyey(float cosTheta, float g){
	float gg = g * g;
	float div =  (1 + gg - 2 * g * cosTheta);
	return ONE_OVER_4_PI * (1 - gg) / sqrt(div * div * div);
}

/*
inline float GetNoiseAtPos(float3 worldPos) {
	float3 coord0 = worldPos * _NoiseScale0.xyz + _NoiseScroll0.xyz;
	float3 coord1 = worldPos * _NoiseScale1.xyz + _NoiseScroll1.xyz;
	float3 coord2 = worldPos * _NoiseScale2.xyz + _NoiseScroll2.xyz;

	float3 noiseValues = float3(
		_NoiseTex0.SampleLevel(MyLinearRepeatSampler, coord0, 0).a,
		_NoiseTex1.SampleLevel(MyLinearRepeatSampler, coord1, 0).a,
		_NoiseTex2.SampleLevel(MyLinearRepeatSampler, coord2, 0).a
		);

	return dot(noiseValues, _NoiseStrength.xyz);
}
*/

inline float GetFaloff(float3 dd, float range) {
	float lightDistanceSqr = dot(dd, dd);
	float ratio2 = lightDistanceSqr * range;
	float num = saturate(1.0f - (ratio2 * ratio2));
	float faloff = (num * num) / (lightDistanceSqr + 1.0f);
	return faloff;
}

[numthreads(4, 4, 4)]
void Scatter(uint3 id : SV_DispatchThreadID) {
	uint wang = wang_hash(id);
	uint xor1 = xorshift(wang);
	uint xor2 = xorshift(xor1);

	float3 jitter = float3(
		wang,
		xor1,
		xor2
		) / UINT_MAX;

	jitter = (jitter - 0.5f) * _TemporalStrength + 0.5f;

	float3 uv = IDToUv(id, jitter);
	
	//TODO: Volumetric shadow?
	float4 fogProps = _DensityTexture.SampleLevel(MyLinearClampSampler, uv, 0.0f);

	float3 directLight = float3(
		_LightReadR.SampleLevel(MyLinearClampSampler, uv, 0.0f),
		_LightReadG.SampleLevel(MyLinearClampSampler, uv, 0.0f),
		_LightReadB.SampleLevel(MyLinearClampSampler, uv, 0.0f) 
		);

	//TODO: Emissive should come from texture...
	float4 scatterExt = float4(fogProps.rgb * (directLight + _EmissivePhase.rgb), fogProps.a);

	float3 device = UvToDevice(uv);
	//Reprojection
	float4 frustum = mul(_VAPOR_REPROJECT, float4(device, 1.0f));
	frustum.xyz /= frustum.w;

	float3 oldUv = DeviceToUv(frustum.xyz);
	float expWeight = any(oldUv - saturate(oldUv)) ? 1.0f : _ExponentialWeight;

	float4 oldVal = _ScatterTextureOld.SampleLevel(MyLinearClampSampler, oldUv, 0.0f);

	_ScatterTexture[id] = expWeight * scatterExt + (1.0f - expWeight) * oldVal;
}


[numthreads(8, 8, 1)]
inline void Integrate(uint3 id : SV_DispatchThreadID){
	uint3 writeId = uint3(id.xy, 0);


	float4 scatterExtWrite = float4(0.0f, 0.0f, 0.0f, 1.0f);
	for(writeId.z = 0; writeId.z < Z_RESOLUTION; ++writeId.z){
		float4 scatterExt = _ScatterTextureOld[writeId];

		//Bit overkill but gets us proper linear dif more or less efficiently.
		float cellLength = DeviceToLinearDepth(UvToDevice(IDToUv(writeId + uint3(0,0,1), 0.5f)).z) - DeviceToLinearDepth(UvToDevice(IDToUv(writeId, 0.5f)).z);
		cellLength *= _PlaneSettings.z / 100.0f;


		float expExtinction = exp(-scatterExt.a * cellLength);
		half3 Sint = scatterExt.rgb * (1 - expExtinction) / (scatterExt.a + 0.00001f);
		
		scatterExtWrite.rgb += scatterExtWrite.a * Sint;
		scatterExtWrite.a *= expExtinction;

		_IntegratedTexture[writeId] = scatterExtWrite; 
	}
}

void WriteLight(uint3 pos, float3 val) {
	_LightAccumR[pos] = val.r;
	_LightAccumG[pos] = val.g;
	_LightAccumB[pos] = val.b;
}
void WriteLightAdd(uint3 pos, float3 val) {
	_LightAccumR[pos] += val.r;
	_LightAccumG[pos] += val.g;
	_LightAccumB[pos] += val.b;
}

float4x4 _SpotMatrix;
float4x4 _SpotShadowMatrix;

void LightDirectionalMain(uint3 id : SV_DispatchThreadID) {
	//Jitter directional too!
	float3 uv = IDToUv(id, float3(0, 0, GetHalton(id, 2)));
	float3 device = UvToDevice(uv);
	float zLocal = DeviceToEye(device.z);
	float3 worldPos = DeviceToWorld(device);

	float3 direction = normalize(_CameraPos.xyz - worldPos + 0.0001f);
	float cosTheta = dot(direction, _LightPosRange.xyz);
	float scatter = GetScatterHenyey(cosTheta, _EmissivePhase.a);

	float shadow = GetShadow(worldPos, zLocal);


	WriteLight(id, scatter * _LightColor.rgb * shadow);
}

[numthreads(4, 4, 4)]
void LightDirectional(uint3 id : SV_DispatchThreadID) {
	LightDirectionalMain(id);
}
[numthreads(4, 4, 4)]
void LightDirectionalShadow(uint3 id : SV_DispatchThreadID) {
	LightDirectionalMain(id);
}[numthreads(4, 4, 4)]
void LightDirectionalShadowCascade(uint3 id : SV_DispatchThreadID) {
	LightDirectionalMain(id);
}

void LightSpotMain(uint3 id : SV_DispatchThreadID) {
	id += _LightWriteLower;
	float3 worldPos = IDToWorld(id, 0.5f);
	float4 lightCoord = mul(_SpotMatrix, float4(worldPos, 1.0f));

	//TODO: In light pass this if should just dissapear naturally
	if (lightCoord.z > 0) {
		float3 direction = normalize(_CameraPos.xyz - worldPos);
		float3 dd = worldPos - _LightPosRange.xyz;
		float faloff = GetFaloff(dd, _LightPosRange.w);

		if (faloff > 0) {
#if SCATTER_SHADOW
			float4 shadowCoord = mul(_SpotShadowMatrix, float4(worldPos, 1.0f));
			shadowCoord.xyz /= shadowCoord.w;

			//From device coords to clip space. 
			//TODO: Apply in matrix?
			shadowCoord.xy = shadowCoord.xy * 0.5f + 0.5f;
			shadowCoord.y = 1.0f - shadowCoord.y;

			float depth = _SpotShadow.SampleLevel(MyLinearClampSampler, shadowCoord.xy, 0.0f).r;
			faloff *= saturate(depth * exp(-_ShadowSoft * saturate(shadowCoord.z)));
#endif

			float cosTheta = dot(direction, normalize(dd));
			float scatter = GetScatterHenyey(cosTheta, _EmissivePhase.a);


			//Apply cookie
			float4 cookie = _SpotCookie.SampleLevel(sampler_SpotCookie, lightCoord.xy / lightCoord.w + 0.5f, 0.0f);
			WriteLightAdd(id, faloff * scatter * _LightColor.rgb * cookie.rgb * cookie.a);
		}
	}
}

[numthreads(4, 4, 4)]
void LightSpot(uint3 id : SV_DispatchThreadID) {
	LightSpotMain(id);
}

[numthreads(4, 4, 4)]
void LightSpotShadow(uint3 id : SV_DispatchThreadID) {
	LightSpotMain(id);
}

[numthreads(4, 4, 4)]
void LightPoint(uint3 id : SV_DispatchThreadID) {
	id += _LightWriteLower;
	float3 worldPos = IDToWorld(id, 0.5f);


	float3 direction = normalize(_CameraPos.xyz - worldPos);
	float3 dd = worldPos - _LightPosRange.xyz;
	float faloff = GetFaloff(dd, _LightPosRange.w);

	if (faloff > 0) {
		float cosTheta = dot(direction, normalize(dd));
		float scatter = GetScatterHenyey(cosTheta, _EmissivePhase.a);

		WriteLightAdd(id, faloff * scatter * _LightColor.rgb);
	}
}



float _NoisePower;
float4 _NoiseSpeed;
float4 _NoiseFrequency; 
float4 _NoiseVal;

[numthreads(4, 4, 4)]
void FogDensity(uint3 id : SV_DispatchThreadID){
	float3 uv = IDToUv(id, float3(0.5f, 0.5f, GetHalton(id, 2)));
	float3 device = UvToDevice(uv);
	float zLocal = DeviceToEye(device.z);
	float3 worldPos = DeviceToWorld(device);
	//Now add cells for local volumes HERE

	//Gather albedo & Extinction
	float2 gradientUv = float2(zLocal * _GradientSettings.z + _GradientSettings.w, worldPos.y * _GradientSettings.x + _GradientSettings.y);
	float4 albedo = _AlbedoExt * _GradientTexture.SampleLevel(sampler_GradientTexture, gradientUv, 0);

	//Exp makes noise a bit more defined
	//albedo.a *= exp(-GetNoiseAtPos(worldPos));




	float ns = tanh(fractal_noise(worldPos * _NoiseFrequency.xyz + _Frame * _NoiseSpeed.xyz) * _NoisePower) * 0.5f + 0.5f;

	albedo *= lerp(_NoiseVal.x, _NoiseVal.y, saturate(ns));
	//albedo.a *= 0.0f;

	//Write old and new value weighed.
	_DensityTextureWrite[id] = albedo;
}


float4x4 _ZoneWorldToLocal;

[numthreads(4, 4, 4)]
void ZoneWrite(uint3 id : SV_DispatchThreadID) {
	id += _LightWriteLower;
	float3 worldPos = IDToWorld(id, 0.5f);

	float3 local = mul(_ZoneWorldToLocal, float4(worldPos, 1.0f)).xyz;

	if (all(abs(local) < 0.5f)) {
		_DensityTextureWrite[id] = _AlbedoExt;
	}
}