#pragma kernel Scatter
#pragma kernel FogDensity SCATTER_SHADOW SHADOW_CASCADE

//TODO: Friggin syntax highlighting
#define ONE_OVER_4_PI (1.0f / 4.0f * 3.141596f)
#define EXP_AVERAGE_WEIGHT 0.05

#define Z_POWER_CURVE 0.02

#define X_RESOLUTION 240
#define Y_RESOLUTION 136
#define Z_RESOLUTION 128

//#define X_RESOLUTION 160
//#define Y_RESOLUTION 88
//#define Z_RESOLUTION 64

//TODO: Just float4 this manually?
struct Light{
	float4 PosRange;
	float4 Intensity;
};
StructuredBuffer<Light> _LightBuffer;
int _LightCount;


//TODO: Make sure halfs are ok
RWTexture3D<half4> _ScatterTexture;
RWTexture3D<half4> _DensityTextureWrite;
Texture3D<half4> _DensityTexture;
Texture3D<half4> _DensityTextureOld;

float4 _NoiseStrength;

#define DECLARE_NOISE_LAYER(n)	\
float4 _NoiseScale##n;			\
float4 _NoiseScroll##n;			\
Texture3D _NoiseTex##n;

float4 _NoiseScale0;
float4 _NoiseScroll0;
Texture3D _NoiseTex0;

//DECLARE_NOISE_LAYER(0)
DECLARE_NOISE_LAYER(1)
DECLARE_NOISE_LAYER(2)

float4 _PlaneSettings;

Texture2D _ShadowMapTexture;

SamplerState MyPointClampSampler;
SamplerState MyLinearRepeatSampler;

//To world & reprojection
float4x4 _VAPOR_I_VP;
float4x4 _VAPOR_VP_OLD;

//Shadow matrices
float4x4 unity_World2Shadow0;
float4x4 unity_World2Shadow1;
float4x4 unity_World2Shadow2;
float4x4 unity_World2Shadow3;

float4 _LightSplitsNear;
float4 _LightSplitsFar;

//Cascade clamp. 
//TODO: Can we do something better?
float4 _Range;

//Main Light data
float4 _LightDirection;
float4 _LightColor;
float _InscatterIntensity;
float _AnisotropyK;
float _FogDensity;
float4 _Ambient;
float4 _CameraPos;

//TODO: Want Uint!!
uint _Frame;

inline float GetHalton(uint3 id){
	float result = 0.0f;
    float f = 1.0f;

	//Halton base of 2
    //Runs maximum of 32 times
	uint index = id.x ^ id.y ^ _Frame;
	//uint index = 0;

	for(uint i = index; i > 0; i >>= 1){ 
		f *= 0.5f;
        result += f * (i & 1);
	}

	return result;
}

inline float GetShadow(float3 wpos, float z){
	float4 multPos = float4(wpos, 1.0f);
	float4 coords;

	//TODO: Conditional for _if_ cascade
	//Figure out cascade weight and final coord in same if
	//Step to clamp atlas to correct cascade
#if SHADOW_CASCADE
	[branch]
	if (z < _LightSplitsFar.x){
		coords = mul(unity_World2Shadow0, multPos);
		coords *= step(coords.x, _Range.x) * step(coords.y, _Range.y);
	}else if (z < _LightSplitsFar.y){
		coords = mul(unity_World2Shadow1, multPos);
		coords *= step(_Range.x, coords.x) * step(coords.y, _Range.y);
	}else if (z < _LightSplitsFar.z){
		coords = mul(unity_World2Shadow2, multPos);
		coords *= step(coords.x, _Range.x) * step(_Range.y, coords.y);
	}else if (z < _LightSplitsFar.w){
		coords = mul(unity_World2Shadow3, multPos);
		coords *= step(_Range.x, coords.x) * step(_Range.y, coords.y);
	}
#else
	coords = mul(unity_World2Shadow0, multPos);
#endif

	//TODO: ESM here
	float depth = _ShadowMapTexture.SampleLevel(MyPointClampSampler, coords.xy / coords.w, 0.0f).r;
	return depth + 0.01f >= saturate(coords.z) ? 1.0f : 0.0f;

	//TODO: Volumetric shadow maps would be so damn sexy
}

float GetScatterHenyey(float cosTheta, float g){
	//TODO: Approximate
	float gg = g * g;
	float div =  (1 + gg - 2 * g * cosTheta);
	return ONE_OVER_4_PI * (1 - gg) / sqrt(div * div * div);

	//float kDiv = (1 + k * cosTheta);
	//return ONE_OVER_4_PI * (1.0f - k * k) / kDiv * kDiv;
}

inline void ScatterMain(uint3 id){
	uint3 writeId = uint3(id.xy, 0);

	half4 currentSliceValue = _DensityTexture[writeId];
	_ScatterTexture[writeId] = currentSliceValue;

	for(writeId.z = 1; writeId.z < Z_RESOLUTION; ++writeId.z){
		half4 nextValue = _DensityTexture[writeId];
		half3 light = currentSliceValue.rgb + exp(-currentSliceValue.a) * nextValue.rgb;
		currentSliceValue = half4(light, currentSliceValue.a + nextValue.a);
		_ScatterTexture[writeId] = currentSliceValue;
	}
}

[numthreads(8, 8, 1)]
void Scatter(uint3 id : SV_DispatchThreadID){
	ScatterMain(id);
}
[numthreads(8, 8, 1)]
void ScatterHiRes(uint3 id : SV_DispatchThreadID){
	ScatterMain(id);
}

//Reprojection code
inline float3 GetRawFrustumFromWorld(float4 worldPos){
	float4 frustum = mul(_VAPOR_VP_OLD, worldPos); //to frustum coords [-1, 1] xy, [0, 1] z
	frustum.xyz /= frustum.w; //normalize projective coordinates
	return frustum.xyz;
}

inline uint3 GetIDFromFrustum(float3 frustum, float zJitter){
	//Only now clamp frustum so GetFrustum can be unclamped
	frustum.z = pow(saturate(frustum.z), 1.0f / Z_POWER_CURVE);

	uint3 id;
	id.z = (uint) round(frustum.z * Z_RESOLUTION - zJitter);
	id.x = (uint) floor((frustum.x + 1.0f) * (X_RESOLUTION * 0.5f));
	id.y = (uint) floor((frustum.y + 1.0f) * (Y_RESOLUTION * 0.5f));

	return id;
}



inline float4 GetFrustumFromID(uint3 id, float haltonOffset){
	//Consistently halton jitter for all functions
	
	//Figure out world pos
	float xUv = (id.x + 0.5f) / (X_RESOLUTION * 0.5f) - 1.0f;
	float yUv = (id.y + 0.5f) / (Y_RESOLUTION * 0.5f) - 1.0f;
	float zUv = saturate((id.z + haltonOffset) / Z_RESOLUTION);
	//Pow the curve to offset 1/z resolution
	zUv = pow(zUv, Z_POWER_CURVE);

	return float4(xUv, yUv, zUv, 1);
}

inline void InjectDensityTex(uint3 id){
	float haltonOffset = GetHalton(id);
	float4 frustCoord = GetFrustumFromID(id, haltonOffset);
}


inline void FogMain(uint3 id){
	//TODO: Groupshare?
	float haltonOffset = GetHalton(id);
	float4 frustCoord = GetFrustumFromID(id, haltonOffset);

	float4 worldPosRaw = mul(_VAPOR_I_VP, frustCoord);
	float3 worldPos = worldPosRaw.xyz / worldPosRaw.w;
	

	float3 coord0 = worldPos * _NoiseScale0.xyz + _NoiseScroll0.xyz;
	float3 coord1 = worldPos * _NoiseScale1.xyz + _NoiseScroll1.xyz;
	float3 coord2 = worldPos * _NoiseScale2.xyz + _NoiseScroll2.xyz;
	
	float3 noiseValues = float3(
		_NoiseTex0.SampleLevel(MyLinearRepeatSampler, coord0, 0).a, 
		_NoiseTex1.SampleLevel(MyLinearRepeatSampler, coord1, 0).a, 
		_NoiseTex2.SampleLevel(MyLinearRepeatSampler, coord2, 0).a
	);




	float zLocal = _PlaneSettings.w * 1.0f / (frustCoord.z - _PlaneSettings.z);
#ifdef SCATTER_SHADOW
	float shadow = GetShadow(worldPos, zLocal);
#else
	float shadow = 1.0f;
#endif

	float4 fog;

	fog.a = lerp(0.0f, _FogDensity, dot(noiseValues, _NoiseStrength.xyz));

	//TODO: Proper volume
	float volume = zLocal * 0.01f;
	fog.a *= volume;

	float3 inScatter = _Ambient.rgb * _Ambient.a;
	float3 direction = normalize(_CameraPos.xyz - worldPos);

	{
		float cosTheta = dot(direction, _LightDirection.xyz);

		//TODO: Better scatter here
		float scatter = GetScatterHenyey(cosTheta, _AnisotropyK);
		inScatter += scatter * _LightColor.rgb * shadow;
	}

	for(int l = 0; l < _LightCount; ++l){
		Light light = _LightBuffer[l];
		float3 dd = worldPos - light.PosRange.xyz;

		float lightDistanceSqr = dot(dd, dd);
		float ratio2 = lightDistanceSqr * light.PosRange.w;
		float num = saturate(1.0f - (ratio2 * ratio2));
		float faloff = (num * num) / (lightDistanceSqr + 1.0f);

		float cosTheta = dot(direction, dd / sqrt(lightDistanceSqr));
		float scatter = GetScatterHenyey(cosTheta, _AnisotropyK);

		inScatter += faloff * scatter * light.Intensity.rgb * _InscatterIntensity * 1.5f;
	}
	
	fog.rgb = inScatter * _InscatterIntensity * (1.0f - exp(-fog.a));

	float3 frustum = GetRawFrustumFromWorld(worldPosRaw);

	//TODO: Must be a better way...
	[branch]
	if (
	abs(frustum.x) < 1.0f && 
	abs(frustum.y) < 1.0f && 
	frustum.z < 1.0f &&
	frustum.z > 0.0f){
		uint3 projectedId = GetIDFromFrustum(frustum, haltonOffset);
		float4 oldVal = _DensityTextureOld[projectedId];
		_DensityTextureWrite[id] = EXP_AVERAGE_WEIGHT * fog + (1.0f - EXP_AVERAGE_WEIGHT) * oldVal;
	}else{
		_DensityTextureWrite[id] = fog;
	}
}

#define TB [numthreads(4, 4, 4)]
//64 threads, blocks of 4x4x4
TB void FogDensity(uint3 id : SV_DispatchThreadID){FogMain(id);}
TB void FogDensityNoShadow(uint3 id : SV_DispatchThreadID){FogMain(id);}